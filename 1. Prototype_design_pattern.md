# 1st solution:
```
A* obj1 = new A(.........);
A* obj2;
obj2->setParam1(obj1->getParam1);
.
.
.
.
.
```
Problem: 1. DRY principle. Sol: We will put this inside a function. Where will this function go? Dont know. 2. Violates OCP. If we add a new param then we will have to chnage this cloning code also. Sol: Put this in the same class as A.

----------------------------------------------------------------------
# 2nd Solution:
```
class A {
  public:
    A(A* obj1) : param1(obj1->param1){}
};

//DRIVER CODE
A* obj1 = new A(.........);
A* obj2 = new A(obj1);
```
Problem: What if class A has a child class? Lets see that in action:

----------------------------------------------------------------------
# 3rd Solution:
```
class A {
  public:
    int x;
    A(int x) : x(x) {}
    A(A* obj1) : x(obj1->x){}
};

class B : public A {
  public:
    int y;
    B(int x, int y) : A(x), y(y) {}
    B(B* obj1) : A(obj1), y(obj1->y){}
};


int main()
{
    A* obj_a = new A(5);
    B* obj_b1 = new B(6, 7);
    
    B* obj_b2 = new B(obj_b1);
    
    cout<<obj_b2->x<<" "<<obj_b2->y;
    return 0;
}
```
OR
```
class A {
  public:
    int x;
    A(int x) : x(x) {}
    A(A& obj1) : x(obj1.x){}
    virtual ~A(){}
};

class B : public A {
  public:
    int y;
    B(int x, int y) : A(x), y(y) {}
    B(B& obj1) : A(obj1), y(obj1.y){}
};


int main()
{
    A obj_a(5);
    B obj_b1(6, 7);
    
    B obj_b2(obj_b1); // same as: B obj_b2 = B(obj_b1);
    
    cout<<obj_b2.x<<" "<<obj_b2.y;
    return 0;
}
```
Problem: In actual code base, out main function wont be looking like this and our cloning steps would be in a function to use the DRY principle. In that case a new problem arises of OCP-:
```
A* createACopy(A* sample) {
    // Check if 'sample' is an instance of B
    if (dynamic_cast<B*>(sample)) {
        B* original_b = static_cast<B*>(sample);
        return new B(original_b);
    } 
    else { // If it's not a B, treat it as a base A
        return new A(sample);
    }
    return nullptr;
}
/*
OR CAN ALSO BE WRITTEN LIKE:
A* createACopy(A* sample) {
    B* objB = dynamic_cast<B*>(sample);
    if (objB) {
        return new B(objB);
    } 
    else { // If it's not a B, treat it as a base A
        return new A(sample);
    }
    return nullptr;
}
*/

int main() {
    A* obj_a = new A(5);
    A* obj_b = new B(6, 7); // Note: Storing a B object in an A pointer

    A* copy_of_a = createACopy(obj_a);
    A* copy_of_b = createACopy(obj_b);
    cout<<copy_of_a->x<<" "<<copy_of_b->x<<" "<<static_cast<B*>(copy_of_b)->y; //casting so as to tell the compiler that we know that copy_of_b is actually of type b
}
```
----------------------------------------------------------------------    
# 4th Solution:
Currently the logic to trigger the right copy constructor resides in the driver code. We dont want that. All the driver code should be doing is to get a clone. Thats it. So what if the object itself has a clone method? Then in that case the case would look like:
```
class A {
  public:
    int x;
    A(int x) : x(x) {}
    A(A* obj1) : x(obj1->x){}
    virtual A* clone() {
        return new A(this);
    }
    virtual ~A(){}
};

class B : public A {
  public:
    int y;
    B(int x, int y) : A(x), y(y) {}
    B(B* obj1) : A(obj1), y(obj1->y){}
    A* clone() override {
        return new B(this);
    }
};


A* createACopy(A* sample) {
    B* objB = dynamic_cast<B*>(sample);
    if (objB) {
        return new B(objB);
    } 
    else { // If it's not a B, treat it as a base A
        return new A(sample);
    }
    return nullptr;
}


int main() {
    A* obj_a = new A(5);
    A* obj_b = new B(6, 7); 

    A* copy_of_a = obj_a->clone();
    A* copy_of_b = obj_b->clone();
    cout<<copy_of_a->x<<" "<<copy_of_b->x<<" "<<static_cast<B*>(copy_of_b)->y;
}
```

----------------------------------------------------------------------    
