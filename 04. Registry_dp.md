You usually create a manager of factories, having a key -value pair.

The technical term for this manager is the Registry design pattern:

Note: 
	•	Use creator-function registry when you want lightweight, runtime-registrable factories (great for plugins).
	•	Use factory-objects (classes) when factories are complex, stateful, or need dependency injection lifetime management.


1. Registry with factory objects
```
#include <iostream>
#include <memory>
#include <string>
#include <unordered_map>
#include <mutex>
#include <stdexcept>

using namespace std;

enum class ChainKey { Admin, StaticFile };

struct Request { string path; };

class Handler {
public:
    Handler(unique_ptr<Handler> n = {}) : next(move(n)) {}
    virtual void handle(Request& r) = 0;
    virtual ~Handler() = default;
protected:
    unique_ptr<Handler> next;
};

class AuthnHandler : public Handler {
public:
    AuthnHandler(unique_ptr<Handler> n = {}) : Handler(move(n)) {}
    void handle(Request& r) override {
        cout << "[Authn] for " << r.path << "\n";
        if(next) next->handle(r);
    }
};

class LoggingHandler : public Handler {
public:
    LoggingHandler(unique_ptr<Handler> n = {}) : Handler(move(n)) {}
    void handle(Request& r) override {
        cout << "[Logging] " << r.path << "\n";
        if(next) next->handle(r);
    }
};

class CompressionHandler : public Handler {
public:
    CompressionHandler(unique_ptr<Handler> n = {}) : Handler(move(n)) {}
    void handle(Request& r) override {
        cout << "[Compression]\n";
        if(next) next->handle(r);
    }
};

class StaticFileHandler : public Handler {
public:
    StaticFileHandler(unique_ptr<Handler> n = {}) : Handler(move(n)) {}
    void handle(Request& r) override {
        cout << "[StaticFileHandler] serving " << r.path << "\n";
        if(next) next->handle(r);
    }
};

struct AbstractHandlerChainFactory {
    virtual unique_ptr<Handler> createChain() = 0;
    virtual ~AbstractHandlerChainFactory() = default;
};

class AdminChainFactory : public AbstractHandlerChainFactory {
public:
    AdminChainFactory() {}
    unique_ptr<Handler> createChain() override {
        unique_ptr<Handler> tail = make_unique<CompressionHandler>();
        tail = make_unique<LoggingHandler>(move(tail));
        tail = make_unique<AuthnHandler>(move(tail));
        return tail;
    }
};

class StaticFileChainFactory : public AbstractHandlerChainFactory {
public:
    StaticFileChainFactory(){}
    unique_ptr<Handler> createChain() override {
        unique_ptr<Handler> tail = make_unique<StaticFileHandler>();
        tail = make_unique<CompressionHandler>(move(tail));
        tail = make_unique<LoggingHandler>(move(tail));
        return tail;
    }
};

struct EnumHash { size_t operator()(ChainKey k) const noexcept { return hash<int>()(static_cast<int>(k)); } };

class ChainFactoryRegistry {
public:
    using FactoryPtr = unique_ptr<AbstractHandlerChainFactory>;
    static ChainFactoryRegistry& instance() {
        static ChainFactoryRegistry r;
        return r;
    }
    void registerFactory(ChainKey key, FactoryPtr f) {
        lock_guard<mutex> g(mu);
        factories.emplace(key, move(f));
    }
    unique_ptr<Handler> createChain(ChainKey key) {
        lock_guard<mutex> g(mu);
        auto it = factories.find(key);
        return it->second->createChain();
    }
private:
    unordered_map<ChainKey, FactoryPtr, EnumHash> factories;
    mutex mu;
    ChainFactoryRegistry() = default;
};

int main() {
    ChainFactoryRegistry::instance().registerFactory(ChainKey::Admin, make_unique<AdminChainFactory>());
    ChainFactoryRegistry::instance().registerFactory(ChainKey::StaticFile, make_unique<StaticFileChainFactory>());

    Request r1{"admin/dashboard"};
    auto adminChain = ChainFactoryRegistry::instance().createChain(ChainKey::Admin);
    adminChain->handle(r1);

    Request r2{"assets/logo.png"};
    auto staticChain = ChainFactoryRegistry::instance().createChain(ChainKey::StaticFile);
    staticChain->handle(r2);

    return 0;
}
```
---------------------------------------------------------------------------------------------------
2. Registry with creator objects
```
#include <iostream>
#include <memory>
#include <functional>
#include <unordered_map>
#include <mutex>
#include <string>
#include <stdexcept>

using namespace std;

enum class ChainKey { Admin, StaticFile };

struct Request { string path; };

class Handler {
public:
    Handler(unique_ptr<Handler> n = {}) : next(move(n)) {}
    virtual void handle(Request& r) = 0;
    virtual ~Handler() = default;
protected:
    unique_ptr<Handler> next;
};

class AuthnHandler : public Handler {
public:
    AuthnHandler(unique_ptr<Handler> n = {}) : Handler(move(n)) {}
    void handle(Request& r) override {
        cout << "Authn\n";
        if(next) next->handle(r);
    }
};

class LoggingHandler : public Handler {
public:
    LoggingHandler(unique_ptr<Handler> n = {}) : Handler(move(n)) {}
    void handle(Request& r) override {
        cout << "Logging " << r.path << "\n";
        if(next) next->handle(r);
    }
};

class CompressionHandler : public Handler {
public:
    CompressionHandler(unique_ptr<Handler> n = {}) : Handler(move(n)) {}
    void handle(Request& r) override {
        cout << "Compress\n";
        if(next) next->handle(r);
    }
};

struct EnumHash { size_t operator()(ChainKey k) { return hash<int>()(static_cast<int>(k)); } };

class ChainFactoryRegistry {
public:
    using Creator = function<unique_ptr<Handler>()>;

    static ChainFactoryRegistry& instance() {
        static ChainFactoryRegistry inst;
        return inst;
    }

    void registerFactory(ChainKey k, Creator c) {
        lock_guard<mutex> lg(mu);
        creators[k] = move(c);
    }

    unique_ptr<Handler> createChain(ChainKey k) {
        lock_guard<mutex> lg(mu);
        auto it = creators.find(k);
        if(it == creators.end()) throw runtime_error("no factory registered for key");
        return it->second(); // invoke the creator
    }

private:
    unordered_map<ChainKey, Creator, EnumHash> creators;
    mutex mu;
    ChainFactoryRegistry() = default;
};

int main() {
    ChainFactoryRegistry::instance().registerFactory(ChainKey::Admin, [](){
        unique_ptr<Handler> tail = make_unique<AdminHandler>();
        tail = make_unique<CompressionHandler>(move(tail));
        tail = make_unique<LoggingHandler>(move(tail));
        tail = make_unique<AuthnHandler>(move(tail));
        return tail;
    });

    ChainFactoryRegistry::instance().registerFactory(ChainKey::StaticFile, [](){
        unique_ptr<Handler> tail = make_unique<StaticFileHandler>();
        tail = make_unique<CompressionHandler>(move(tail));
        tail = make_unique<LoggingHandler>(move(tail));
        return tail;
    });

    Request r1{"admin/dashboard"};
    auto adminChain = ChainFactoryRegistry::instance().createChain(ChainKey::Admin);
    adminChain->handle(r1);

    Request r2{"assets/logo.png"};
    auto staticChain = ChainFactoryRegistry::instance().createChain(ChainKey::StaticFile);
    staticChain->handle(r2);

    return 0;
}
```
